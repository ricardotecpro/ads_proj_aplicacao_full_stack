## üì± M√≥dulo 4: Cliente Mobile com Android (`listadetarefas-android`)

**Objetivo:** Completar o ecossistema com um cliente Android nativo e moderno, utilizando as melhores pr√°ticas recomendadas pelo Google, como Jetpack Compose e ViewModel.

### üõ†Ô∏è Ferramentas Necess√°rias

  * **Android Studio:** A IDE oficial para desenvolvimento Android (vers√£o "Hedgehog" ou mais recente).
  * **Android SDK:** Instalado via Android Studio.
  * **Emulador Android (AVD)** ou um dispositivo f√≠sico.

### \#\#\# üìÇ Passo 1: Cria√ß√£o do Projeto

1.  No **Android Studio**, v√° em **File \> New \> New Project...**.
2.  Selecione o template **Empty Activity** (com o logo do Compose).
3.  Configure o projeto:
      * **Name:** `listadetarefas-android`
      * **Package name:** `br.com.curso.listadetarefas.android`
      * **Minimum SDK:** API 24 ou superior.
4.  Clique em **Finish**.

#### Estrutura Inicial de Pastas

O Android Studio gerar√° uma estrutura complexa. Focaremos na pasta principal do nosso c√≥digo:

```
listadetarefas-android/
‚îî‚îÄ‚îÄ app/
    ‚îî‚îÄ‚îÄ src/
        ‚îî‚îÄ‚îÄ main/
            ‚îú‚îÄ‚îÄ java/
            ‚îÇ   ‚îî‚îÄ‚îÄ br/com/curso/listadetarefas/android/
            ‚îÇ       ‚îî‚îÄ‚îÄ MainActivity.kt
            ‚îî‚îÄ‚îÄ AndroidManifest.xml
```

### \#\#\# ‚öôÔ∏è Passo 2: Configura√ß√£o do Projeto

1.  **Adicionar Depend√™ncias:** Abra o arquivo `app/build.gradle.kts` e adicione as depend√™ncias para Retrofit (cliente HTTP) e Gson (conversor JSON) na se√ß√£o `dependencies { ... }`.

```kts
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("org.jetbrains.kotlin.plugin.compose")
}

android {
    namespace = "br.com.curso.listadetarefas.android"
    compileSdk = 34

    defaultConfig {
        applicationId = "br.com.curso.listadetarefas.android"
        // --- CORRE√á√ÉO AQUI ---
        minSdk = 26 // Alterado de 24 para 26 para suportar √≠cones adaptativos
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    // --- Depend√™ncias Principais do AndroidX ---
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.activity:activity-compose:1.8.2")

    // --- Jetpack Compose ---
    val composeBom = platform("androidx.compose:compose-bom:2024.02.01")
    implementation(composeBom)
    androidTestImplementation(composeBom)

    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.compose.material:material-icons-extended")

    // --- ViewModel com Compose ---
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")

    // --- Networking: Retrofit e OkHttp ---
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")

    // --- Testes ---
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}
```

2.  **Adicionar Permiss√µes de Rede:** Abra o arquivo `app/src/main/AndroidManifest.xml` e adicione a permiss√£o de internet e a permiss√£o para tr√°fego de texto limpo (necess√°rio para `localhost` em desenvolvimento).

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.INTERNET" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:usesCleartextTraffic="true"
        android:theme="@style/Theme.Listadetarefasandroid">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.Listadetarefasandroid">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

### \#\#\# üîó Passo 3: Configura√ß√£o da Rede para o Emulador

1.  **Pr√©-requisito:** A API backend deve estar rodando com `server.address=0.0.0.0`.


Abra o arquivo `src/main/resources/application.properties` e substitua seu conte√∫do por este:

```properties
# Permite que o servidor aceite conex√µes de qualquer endere√ßo de rede da m√°quina.
server.address=0.0.0.0



2.  **Crie o T√∫nel Reverso:** Com o emulador Android em execu√ß√£o, abra um terminal e execute o comando:
    ```bash
    adb reverse tcp:8080 tcp:8080
    ```
      * **Explica√ß√£o:** Este comando redireciona as requisi√ß√µes feitas para a porta `8080` do emulador para a porta `8080` da sua m√°quina (onde a API est√° rodando).

### \#\#\# ‚úçÔ∏è Passo 4: Codifica√ß√£o da Camada de Dados e Rede

1.  Dentro do pacote `br.com.curso.listadetarefas.android`, crie os seguintes arquivos Kotlin:

**`Tarefa.kt` (Modelo de Dados)**

```kotlin
package br.com.curso.listadetarefas.android
// data class gera automaticamente getters, setters, equals, etc.
data class Tarefa(
    val id: Long?,
    var descricao: String?,
    var concluida: Boolean
)
```

**`TarefaApiService.kt` (Interface da API)**

```kotlin
package br.com.curso.listadetarefas.android
import retrofit2.Response
import retrofit2.http.*

interface TarefaApiService {
    @GET("tarefas")
    suspend fun getTarefas(): List<Tarefa>
    @POST("tarefas")
    suspend fun addTarefa(@Body tarefa: Tarefa): Tarefa
    @PUT("tarefas/{id}")
    suspend fun updateTarefa(@Path("id") id: Long, @Body tarefa: Tarefa): Tarefa
    @DELETE("tarefas/{id}")
    suspend fun deleteTarefa(@Path("id") id: Long): Response<Void>
}
```

**`RetrofitClient.kt` (Cliente HTTP)**

```kotlin
package br.com.curso.listadetarefas.android
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

object RetrofitClient {
    // 127.0.0.1 √© o endere√ßo de localhost para o emulador Android (ap√≥s o adb reverse).
    private const val BASE_URL = "http://127.0.0.1:8080/api/"
    val instance: TarefaApiService by lazy {
        val logging = HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }
        val httpClient = OkHttpClient.Builder().addInterceptor(logging).build()
        val retrofit = Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .client(httpClient)
            .build()
        retrofit.create(TarefaApiService::class.java)
    }
}
```

#### Estrutura de Pastas Ap√≥s a Cria√ß√£o da Rede

```
android/
‚îî‚îÄ‚îÄ app/src/main/java/br/com/curso/listadetarefas/android/
    ‚îú‚îÄ‚îÄ MainActivity.kt
    ‚îú‚îÄ‚îÄ RetrofitClient.kt     # <- Arquivo criado
    ‚îú‚îÄ‚îÄ Tarefa.kt             # <- Arquivo criado
    ‚îî‚îÄ‚îÄ TarefaApiService.kt   # <- Arquivo criado
```

### \#\#\# üèóÔ∏è Passo 5: Constru√ß√£o do ViewModel e da UI com Compose

#### Diagrama de Classes do Cliente Mobile

```mermaid
classDiagram
    MainActivity ..> TarefaViewModel : Observa
    TarefaViewModel ..> RetrofitClient : Usa
    RetrofitClient ..> TarefaApiService : Cria
    TarefaViewModel ..> Tarefa : Gerencia Estado (UiState)
    class MainActivity {
        +TarefaApp() Composable
    }
    class TarefaViewModel {
        -StateFlow~TarefaUiState~ uiState
        +carregarTarefas()
        +adicionarTarefa(String)
        +updateTarefa(Tarefa)
        +deleteTarefa(Long)
    }
    class RetrofitClient {
        <<Object>>
        +TarefaApiService instance
    }
    class TarefaApiService {
        <<Interface>>
    }
```

1.  Crie o arquivo `TarefaViewModel.kt` e substitua o conte√∫do de `MainActivity.kt`.

**`TarefaViewModel.kt`**

```kotlin
// Cole o c√≥digo completo da classe TarefaViewModel do guia anterior aqui.
// Ele cont√©m a classe TarefaUiState e a l√≥gica para carregar, adicionar,
// atualizar e deletar tarefas usando Coroutines.
package br.com.curso.listadetarefas.android

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

data class TarefaUiState(
    val tarefas: List<Tarefa> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)
class TarefaViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(TarefaUiState())
    val uiState: StateFlow<TarefaUiState> = _uiState.asStateFlow()
    private val TAG = "TarefaViewModel"

    init { carregarTarefas() }

    fun carregarTarefas() {
        _uiState.update { it.copy(isLoading = true) }
        viewModelScope.launch {
            try {
                val tarefasDaApi = withContext(Dispatchers.IO) { RetrofitClient.instance.getTarefas() }
                _uiState.update { it.copy(isLoading = false, tarefas = tarefasDaApi, error = null) }
            } catch (e: Exception) {
                Log.e(TAG, "Falha ao carregar tarefas", e)
                _uiState.update { it.copy(isLoading = false, error = "Falha ao carregar tarefas") }
            }
        }
    }
    fun adicionarTarefa(descricao: String) {
        viewModelScope.launch {
            try {
                val tarefaAdicionada = withContext(Dispatchers.IO) {
                    RetrofitClient.instance.addTarefa(Tarefa(id = null, descricao = descricao, concluida = false))
                }
                _uiState.update { it.copy(tarefas = it.tarefas + tarefaAdicionada) }
            } catch (e: Exception) { Log.e(TAG, "Falha ao adicionar tarefa", e) }
        }
    }
    fun updateTarefa(tarefa: Tarefa) {
        viewModelScope.launch {
            try {
                tarefa.id?.let {
                    val tarefaAtualizada = withContext(Dispatchers.IO) { RetrofitClient.instance.updateTarefa(it, tarefa) }
                    _uiState.update { currentState ->
                        currentState.copy(tarefas = currentState.tarefas.map { t -> if (t.id == tarefaAtualizada.id) tarefaAtualizada else t })
                    }
                }
            } catch (e: Exception) { Log.e(TAG, "Falha ao atualizar tarefa", e) }
        }
    }
    fun deleteTarefa(id: Long?) {
        viewModelScope.launch {
            try {
                id?.let {
                    withContext(Dispatchers.IO) { RetrofitClient.instance.deleteTarefa(it) }
                    _uiState.update { currentState -> currentState.copy(tarefas = currentState.tarefas.filter { t -> t.id != id }) }
                }
            } catch (e: Exception) { Log.e(TAG, "Falha ao deletar tarefa", e) }
        }
    }
}
```

**`MainActivity.kt`**

```kotlin
@file:OptIn(ExperimentalMaterial3Api::class)
package br.com.curso.listadetarefas.android

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
// --- REMOVER IMPORTS ANTIGOS ---
// import androidx.compose.material.pullrefresh.PullRefreshIndicator
// import androidx.compose.material.pullrefresh.pullRefresh
// import androidx.compose.material.pullrefresh.rememberPullRefreshState
import androidx.compose.material3.*
// --- ADICIONAR NOVO IMPORT DO MATERIAL 3 ---
import androidx.compose.material3.pulltorefresh.PullToRefreshContainer
import androidx.compose.material3.pulltorefresh.rememberPullToRefreshState
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import br.com.curso.listadetarefas.android.ui.theme.listadetarefasAndroidTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            listadetarefasAndroidTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
                    TarefaApp()
                }
            }
        }
    }
}

@Composable
fun TarefaApp(tarefaViewModel: TarefaViewModel = viewModel()) {
    val uiState by tarefaViewModel.uiState.collectAsState()
    var tarefaParaEditar by remember { mutableStateOf<Tarefa?>(null) }

    // --- MUDAN√áA: Usar o rememberPullToRefreshState do Material 3 ---
    val pullToRefreshState = rememberPullToRefreshState()

    // L√≥gica para lidar com a atualiza√ß√£o
    if (pullToRefreshState.isRefreshing) {
        LaunchedEffect(true) {
            tarefaViewModel.carregarTarefas()
        }
    }

    // L√≥gica para parar a anima√ß√£o de refresh quando o carregamento terminar
    LaunchedEffect(uiState.isLoading) {
        if (!uiState.isLoading) {
            pullToRefreshState.endRefresh()
        }
    }

    Scaffold(topBar = { TopAppBar(title = { Text("To-Do List Android") }) }) { paddingValues ->
        // --- MUDAN√áA: Usar PullToRefreshBox ---
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .nestedScroll(pullToRefreshState.nestedScrollConnection)
        ) {
            if (uiState.error != null) {
                Text(
                    text = "Erro: ${uiState.error}",
                    modifier = Modifier.align(Alignment.Center),
                    textAlign = TextAlign.Center
                )
            } else {
                // O conte√∫do da tela (a lista) vai aqui dentro
                TarefaScreen(
                    tarefas = uiState.tarefas,
                    isLoading = uiState.isLoading,
                    onAddTask = tarefaViewModel::adicionarTarefa,
                    onUpdateTask = tarefaViewModel::updateTarefa,
                    onDeleteTask = tarefaViewModel::deleteTarefa,
                    onTaskClick = { tarefa -> tarefaParaEditar = tarefa }
                )
            }

            // O indicador de refresh agora √© o PullToRefreshContainer
            PullToRefreshContainer(
                state = pullToRefreshState,
                modifier = Modifier.align(Alignment.TopCenter)
            )

            // O di√°logo de edi√ß√£o permanece o mesmo
            tarefaParaEditar?.let { tarefa ->
                EditTaskDialog(
                    tarefa = tarefa,
                    onDismiss = { tarefaParaEditar = null },
                    onSave = { novaDescricao ->
                        val tarefaAtualizada = tarefa.copy(descricao = novaDescricao)
                        tarefaViewModel.updateTarefa(tarefaAtualizada)
                        tarefaParaEditar = null
                    }
                )
            }
        }
    }
}

@Composable
fun TarefaScreen(
    tarefas: List<Tarefa>,
    isLoading: Boolean,
    onAddTask: (String) -> Unit,
    onUpdateTask: (Tarefa) -> Unit,
    onDeleteTask: (Long?) -> Unit,
    onTaskClick: (Tarefa) -> Unit
) {
    var textoNovaTarefa by remember { mutableStateOf("") }
    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            OutlinedTextField(
                value = textoNovaTarefa,
                onValueChange = { textoNovaTarefa = it },
                label = { Text("Nova tarefa") },
                modifier = Modifier.weight(1f)
            )
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                if (textoNovaTarefa.isNotBlank()) {
                    onAddTask(textoNovaTarefa)
                    textoNovaTarefa = ""
                }
            }) { Text("Add") }
        }
        Spacer(modifier = Modifier.height(16.dp))
        // A l√≥gica de exibi√ß√£o (loading, lista vazia, lista com itens) permanece a mesma
        if (isLoading && tarefas.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else if (tarefas.isEmpty()) {
            Text(
                text = "Nenhuma tarefa encontrada.\nPuxe para atualizar ou adicione uma nova!",
                modifier = Modifier.fillMaxWidth().padding(top = 32.dp),
                textAlign = TextAlign.Center
            )
        } else {
            LazyColumn(modifier = Modifier.fillMaxSize()) {
                items(tarefas, key = { it.id!! }) { tarefa ->
                    TarefaItem(
                        tarefa = tarefa,
                        onCheckedChange = { isChecked -> onUpdateTask(tarefa.copy(concluida = isChecked)) },
                        onDeleteClick = { onDeleteTask(tarefa.id) },
                        onTaskClick = { onTaskClick(tarefa) }
                    )
                    Divider()
                }
            }
        }
    }
}

@Composable
fun TarefaItem(
    tarefa: Tarefa,
    onCheckedChange: (Boolean) -> Unit,
    onDeleteClick: () -> Unit,
    onTaskClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onTaskClick() }
            .padding(vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Checkbox(checked = tarefa.concluida, onCheckedChange = onCheckedChange)
        Text(
            text = tarefa.descricao ?: "",
            modifier = Modifier
                .weight(1f)
                .padding(horizontal = 8.dp),
            style = if (tarefa.concluida) LocalTextStyle.current.copy(textDecoration = TextDecoration.LineThrough) else LocalTextStyle.current
        )
        IconButton(onClick = onDeleteClick) {
            Icon(Icons.Filled.Delete, contentDescription = "Deletar Tarefa")
        }
    }
}

@Composable
fun EditTaskDialog(tarefa: Tarefa, onDismiss: () -> Unit, onSave: (String) -> Unit) {
    var textoEditado by remember { mutableStateOf(tarefa.descricao ?: "") }
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Editar Tarefa") },
        text = {
            OutlinedTextField(
                value = textoEditado,
                onValueChange = { textoEditado = it },
                label = { Text("Descri√ß√£o") },
                modifier = Modifier.fillMaxWidth()
            )
        },
        confirmButton = { Button(onClick = { if (textoEditado.isNotBlank()) { onSave(textoEditado) } }) { Text("Salvar") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancelar") } }
    )
}
```

### \#\#\# ‚úÖ Passo 1: Garantir que a API est√° a ser executada e o t√∫nel de rede est√° ativo

Antes de iniciar a aplica√ß√£o Android, √© essencial que a API j√° esteja a ser executada.

Use a op√ß√£o 1 no seu painel de controlo para Iniciar a API.

Confirme que o status da "API Backend" muda para RUNNING.

Use a op√ß√£o 7 para Iniciar a App Android. O script ir√° executar automaticamente o comando adb reverse, que cria a ponte de rede necess√°ria.

### \#\#\# ‚úÖ Passo 2: Permitir Tr√°fego de Rede no Android (Configura√ß√£o Essencial)

Por defeito, as vers√µes mais recentes do Android bloqueiam a comunica√ß√£o com endere√ßos que n√£o sejam seguros (n√£o-HTTPS), como √© o caso do nosso ambiente de desenvolvimento local. Precisamos de dizer explicitamente √† aplica√ß√£o que esta comunica√ß√£o √© permitida.

### \#\#\# ‚úÖ Passo 3: Crie um novo ficheiro de configura√ß√£o:

Na estrutura de pastas do seu projeto Android, navegue para app/src/main/res.

Crie uma nova pasta chamada xml.

Dentro da pasta xml, crie um novo ficheiro chamado network_security_config.xml.

### \#\#\# ‚úÖ Passo 4: Adicione o seguinte conte√∫do a network_security_config.xml:

```XML
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">127.0.0.1</domain>
    </domain-config>
</network-security-config>
```

### \#\#\# ‚úÖ Passo 5: Atualize o AndroidManifest.xml:

Abra o ficheiro app/src/main/AndroidManifest.xml.

Adicione a seguinte linha dentro da tag <application>:

```XML
<application
    ...
    android:networkSecurityConfig="@xml/network_security_config">
    ...
</application>
```

Depois de fazer estas altera√ß√µes no projeto Android, compile e execute a aplica√ß√£o novamente atrav√©s do painel de controle.


### \#\#\# ‚úÖ Passo 6: Execu√ß√£o e Teste

1.  **Execute a Aplica√ß√£o:** No Android Studio, selecione o emulador e clique no bot√£o "Run 'app'".
2.  **Teste e Depure:**
      * **Ferramenta Principal:** **Logcat**. Use a janela do Logcat no Android Studio para ver logs da aplica√ß√£o, erros de rede e exce√ß√µes.
      * **Roteiro de Teste:**
        1.  Adicione, edite (tocando na descri√ß√£o), marque como conclu√≠da e delete tarefas.
        2.  Arraste a lista para baixo para testar a funcionalidade de "Puxar para Atualizar".

-----